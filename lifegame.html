<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LifeGame</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    // シェーダーソースコード
    const vertexShaderSource = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;

      uniform sampler2D currentState;
      uniform vec2 resolution;

      void main() {
        vec2 uv = gl_FragCoord.xy / resolution;
        vec4 currentCell = texture2D(currentState, uv);

        // ライフゲームのルールを適用して次の状態を計算
        // ここでは単純なライフゲームのルールを適用していますが、他のルールを試すこともできます
        int neighbors = int(
          texture2D(currentState, uv + vec2(-1.0, -1.0)).r +
          texture2D(currentState, uv + vec2(0.0, -1.0)).r +
          texture2D(currentState, uv + vec2(1.0, -1.0)).r +
          texture2D(currentState, uv + vec2(-1.0, 0.0)).r +
          texture2D(currentState, uv + vec2(1.0, 0.0)).r +
          texture2D(currentState, uv + vec2(-1.0, 1.0)).r +
          texture2D(currentState, uv + vec2(0.0, 1.0)).r +
          texture2D(currentState, uv + vec2(1.0, 1.0)).r
        );

        float nextState = 0.0;
        if (currentCell.r > 0.5) {
          if (neighbors < 2 || neighbors > 3) {
            nextState = 0.0;
          } else {
            nextState = 1.0;
          }
        } else {
          if (neighbors == 3) {
            nextState = 1.0;
          }
        }

        gl_FragColor = vec4(vec3(nextState), 1.0);
      }
    `;

    // シェーダーコンパイル
    function compileShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    // プログラムオブジェクトの生成とリンク
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
    }

    gl.useProgram(program);

    // 頂点バッファの作成
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [-1, -1, 3, -1, -1, 3];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    // 頂点属性の有効化とポインタの設定
    const positionLocation = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    // テクスチャの初期状態をランダムに設定
    const texSize = [canvas.width, canvas.height];
    const pixels = new Uint8Array(canvas.width * canvas.height * 4);
    for (let i = 0; i < canvas.width * canvas.height; i++) {
      pixels[i * 4 + 3] = Math.random() > 0.5 ? 255 : 0;
    }

    // テクスチャの生成と初期化
    const currentStateTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, currentStateTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    // uniform変数の位置の取得
    const currentStateLocation = gl.getUniformLocation(program, 'currentState');
    const resolutionLocation = gl.getUniformLocation(program, 'resolution');

    // レンダリングループ
    function render() {
      // ライフゲームの計算
      gl.uniform1i(currentStateLocation, 0);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, currentStateTexture);

      gl.uniform2fv(resolutionLocation, texSize);

      gl.drawArrays(gl.TRIANGLES, 0, 3);

      // テクスチャを更新
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>
